<<category VSC VectorSpaceCategory>>=
)abbrev category VSC VectorSpaceCategory
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 7 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
VectorSpaceCategory(R : Ring) : Category == with

    -- Addition of vectors
    "+": (%, %) -> %

    -- Subtraction and unary minus of vectors
    "-": (%, %) -> %
    "-": % -> %

    -- Multiplication by scalars from base field / ring
    "*": (R, %) -> %
    "*": (%, R) -> %

    -- Equality of vectors
    "=": (%, %) -> Boolean

  add
    (x:% - y:%) :% == x + (-1)::R * y
    (-x:%) :% == (-1)::R * x
    (x:% * r:R) :% == r * x

    -- what about others?
    -- x = y ==


<<category VAC VectorAlgebraCategory>>=
)abbrev category VAC VectorAlgebraCategory
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 7 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
++
++ Axioms:
++   \spad{ (a+b)^c = a^c + b^c }
++   \spad{ a^b = -b^a }
++   \spad{ a^(b^c) = (a.c)*b - (a.b)*c }
++   \spad{ (abc) = (bca) } where \spad{(abc)} denotes \spad{(a^b).c}
++   \spad{ (abc) = 0 } implies that \spad{a, b, c} are linearly dependent
VectorAlgebraCategory(R : Ring) : Category == VectorSpaceCategory(R) with

    vector: Symbol -> %
      ++ Create a symbolic component-free vector object

    scalarZero: () -> %
      ++ Create a scalar zero object

    vectorZero: () -> %
      ++ Create a vector zero object

    isVector?: % -> Boolean
      ++ Test if the given expression is really a vector

    "*": (%, %) -> %
      ++ Dot product
      -- Possible confusion with inherited r:R*v:% from VSC?

    "^": (%, %) -> %
      ++ Vector cross/wedge product
      -- rather use "/\"?

    s3p: (%, %, %) -> %
      ++ Triple vector product

    simplify: % -> %

    identity?: (%, %) -> Boolean

  add

    s3p(x:%, y:%, z:%) :% == (x^y) * z



<<domain VA VectorAlgebra>>=
)abbrev domain VA VectorAlgebra
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 7 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
VectorAlgebra(R : Ring) : VectorAlgebraCategory(R) == Implementation where

  INT ==> Integer


  Exports == with

    --normalForm: % -> %
    -- What can we gain by exporting this?
      ++ Bring the vector expression into a normal form
      ++ of type [coef, sca, vec]
      ++ Example of a normal form:
      ++ -2 * (a.b)*(abc) * (c^d)
      ++ [-2, [[a, b],[a, b, c]], [c, d]]

    --termOrder:
    -- What can we gain by exporting this?
      ++ Reorder the terms by the term order constructed

    simplify: % -> %
      ++ Simplify a given vector expression by first
      ++ bring it to the normal form, then apply
      ++ transformation rules


  Implementation == add

    -- Basic data types used:
    coePart == R
    scaPart == List(List(String))
    vecPart == List(String)
    -- we dont want to use Strings, rather Exprs? Symbols? Variables?

    -- A single term alpha * a * v
    Term == Record(coe:R, sca:scaPart, vec:vecPart )

    -- Normal form is sum of terms
    Rep := List Term


    -- Further structures used for simplification
    scaTerm == Record(coe2:R, sca2:scaPart )
    scaList == List(scaTerm)
    mixTerm == Record(scal: scaList, vec2: vecPart )

    -- Extract single parts out of terms
    -- Do we need really this?
    coefPart(x:Term) : R == x.coe
    scalarPart(x:Term) : scaPart == x.sca
    vectorPart(x:Term) : vecPart == x.vec

    -- Check term for beeing zero
    szero?(x:Term) :Boolean ==
      -- Coefficient is zero and there is no vector part
      -- But what about scalar part?
      x.coe = 0 and empty? x.vec

    vzero?(x:Term) :Boolean ==
      -- Vector is zero or multiplied by zero coefficient
      -- But what about scalar part?
      empty? x.vec or (x.coe = 0 and ~empty? x.vec)
      -- and this one:
      -- or x.vec(1)::R = 0::R

    -- Construct new domain elements
    scalarZero() :% == ([ [0, [], []] ])::%

    vectorZero() :% == ([ [0, [], ["0"]] ])::%
      -- TODO: Fix "0" here

    --vector(x:Symbol) :% == ([ [1::R, [], [name x]] ])::Rep::%
      -- Does not compile, why? Need to quote x somehow?
      -- Recheck if we could omit the 1

    -- Check if an expression is a true vector (possibly zero)
    -- or just a scalar expression. Examples for single terms:
    -- [a, [], []]  scalar
    -- [a, [...], []]  scalar
    -- [0, [...], []]  scalar
    -- [0, [], []]  scalar
    -- [0, [...], [0]]  zero-vector
    -- [a, [...], [0]]  zero-vector
    -- [a, [0,0], [0]]  zero-vector
    -- [a, [...], [v]]  vector
    -- [a, [...], [v, w]]  vector
    -- [0, [...], [u, v, w]]  vector? (triple product evaluated result in scalar!)
    isVector?(x:%) :Boolean ==
      xx := x::Rep
      -- Empty expression / normal form
      empty? xx => false
      -- We can only sum up compatible terms in the normal form
      -- hence search if there is a term which is not a vector
      result :Boolean := true
      for tx in xx repeat
        empty? tx.vec => (result := false)
      result

    -- Bring the vector expression into a normal form
    -- of type [coef, sca, vec]
    -- Example of a normal form:
    -- -2 * (a.b)*(abc) * (c^d)
    -- [-2, [[a, b],[a, b, c]], [c, d]]
    normalForm(x:Rep) :Rep ==
      -- for all tx in x::Rep
      --   make scalar part and vector part and check for zero
      --   collect non-zero terms in yy::Rep
      --   sort yy in ascending order and return y::%
      l : List(Term) := empty()
      tf : INT := 0

      for tx in x repeat
        szero? tx => l := l
        vzero? tx => tf := 1
        l := cons(tx, l)

      empty? l and tf = 0 => ([ [0, [], [] ] ])::Rep
      empty? l and tf = 1 => ([ [0, [], ["0"]] ])::Rep
        -- TODO: Fix "0" here

      reverse! l
      l::Rep

    -- Do we really want to make this available, for what?
    -- Issue: makes "something" looping
    --normalForm(x:%) :% ==
    --  normalForm(x::Rep)::%

    -- Implementation of algebraic operations

    -- Addition
    (x:% + y:%) :% ==
      zz := append(x::Rep, y::Rep)
      normalForm(zz)::%

    -- Scalar times vector
    (r:R * x:%) :% ==
      xx := x::Rep
      zz := [ [r*tx.coe, tx.sca, tx.vec] for tx in xx ]
      normalForm(zz)::%

    -- Scalar product of two vectors
    (x:% * y:%) :% ==
      xx := x::Rep
      yy := y::Rep

      l : Rep := empty()

      for tx in xx repeat
        nx:INT := # tx.vec

        for ty in yy repeat
          ny:INT := # ty.vec

          -- TODO: I'd like to use a else-if structure here, but it becomes too clumpsy! maybe try using "iterate"
          vx := tx.vec
          vy := ty.vec

          if nx = 1 and ny = 1 then
            scap := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            m := [tx.coe * ty.coe, scap, []]@Term
            l := cons(m,l)

          if nx = 1 and ny = 2 then
            scap := cons([vx(1),vy(1),vy(2)], append(tx.sca,ty.sca))
            m := [tx.coe*ty.coe, scap, []]@Term
            l := cons(m,l)

          if nx = 2 and ny = 1 then
            scap := cons([vx(1),vx(2),vy(1)], append(tx.sca,ty.sca))
            m := [tx.coe*ty.coe, scap, []]@Term
            l := cons(m,l)

          if nx = 2 and ny = 2 then
            coep := tx.coe * ty.coe
            scap1 := [[vx(1),vy(1)], [vx(2),vy(2)]]
            scap2 := [[vx(1),vy(2)], [vx(2),vy(1)]]
            m1 := [coep, append(scap1,append(tx.sca,ty.sca)), []]@Term
            m2 := [(-1)*coep, append(scap2,append(tx.sca,ty.sca)), []]@Term
            l := cons(m2, cons(m1,l))

      zz := normalForm reverse! l
      zz::%

    -- Cross product of two vectors
    (x:% ^ y:%) :% ==
      xx := x::Rep
      yy := y::Rep

      l : Rep := empty()

      for tx in xx repeat
        nx:INT := # tx.vec

        for ty in yy repeat
          ny:INT := # ty.vec

          -- TODO: I'd like to use a else-if structure here, but it becomes too clumpsy! try using "iterate"
          vx := tx.vec
          vy := ty.vec

          if nx = 1 and ny = 1 then
            m := [tx.coe*ty.coe, append(tx.sca,ty.sca), append(tx.vec,ty.vec)]@Term
            l := cons(m,l)

          if nx = 1 and ny = 2 then
            coep := tx.coe * ty.coe
            scap1 := cons([vx(1),vy(2)], append(tx.sca,ty.sca))
	    scap2 := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vy(1)]]@Term
            m2 := [(-1)*coep, scap2, [vy(2)]]@Term
            l := cons(m2, cons(m1,l))

          if nx = 2 and ny = 1 then
            coep := tx.coe * ty.coe
            scap1 := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            scap2 := cons([vx(2),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vx(2)]]@Term
            m2 := [(-1)*coep, scap2, [vx(1)]]@Term
            l := cons(m2, cons(m1,l))

          if nx = 2 and ny = 2 then
            coep := tx.coe * ty.coe
	    scap1 := cons([vx(1),vx(2),vy(2)], append(tx.sca,ty.sca))
	    scap2 := cons([vx(1),vx(2),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vy(1)]]@Term
            m2 := [(-1)*coep, scap2, [vy(2)]]@Term
            l := cons(m2, cons(m1,l))

      zz := normalForm reverse! l
      zz::%

    -- Term order functions

    vectorOrder?(v1:vecPart, v2:vecPart) : Boolean ==
      empty? v1 => true
      empty? v2 => false
      n1 := #v1
      n2 := #v2
      n1 < n2 => true
      n1 > n2 => false

      -- Case n1 = n2
      result := true
      for i in 1..n1 repeat
        if v1(i) < v2(i) then
          result := true
          break

        if v1(i) > v2(i) then
          result := false
          break

      result

    vectorEq?(v1:vecPart, v2:vecPart) : Boolean ==
      empty? v1 and empty? v2 => true
      empty? v1 and not empty? v2 => false
      n1 := #v1
      n2 := #v2
      n1 ~= n2 => false

      -- Case n1 = n2
      result := true
      for i in 1..n1 repeat
        if v1(i) ~= v2(i) then
          result := false
          break

      result

    scalarOrder?(s1:scaPart, s2:scaPart) : Boolean ==
      empty? s1 => true
      empty? s2 => false
      n1 := #s1
      n2 := #s2
      n1 < n2 => true
      n1 > n2 => false
      result := true

      -- Case n1 = n2
      for i in 1..n1 repeat
        if vectorOrder?(s1(i), s2(i)) and not vectorEq?(s1(i), s2(i)) then
          result := true
          break

        if not vectorOrder?(s1(i), s2(i)) then
          result := false
          break

      result

    scalarEq?(s1:scaPart, s2:scaPart) : Boolean ==
      empty? s1 and empty? s2 => true
      empty? s1 and not empty? s2 => false
      n1 := #s1
      n2 := #s2
      n1 ~= n2 => false
      result := true

      -- Case n1 = n2
      for i in 1..n1 repeat
        if not vectorEq?(s1(i), s2(i)) then
          result := false
          break

      result

    termOrder?(t1:Term, t2:Term) : Boolean ==
      szero? t1 or vzero? t1 => true
      szero? t2 or vzero? t2 => false

      vectorOrder?(t1.vec, t2.vec) and not vectorEq?(t1.vec, t2.vec) => true
      not vectorEq?(t1.vec, t2.vec) => false

      scalarOrder?(t1.sca, t2.sca) and not scalarEq?(t1.sca, t2.sca) => true
      not scalarEq?(t1.sca, t2.sca) => false

      true

    termEq?(t1:Term, t2:Term) : Boolean ==
      t1.coe = t2.coe and scalarEq?(t1.sca, t2.sca) and vectorEq?(t1.vec, t2.vec) => true
