<<category VSC VectorSpaceCategory>>=
)abbrev category VSC VectorSpaceCategory
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 12 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
VectorSpaceCategory(R : Ring) : Category == with

    -- Addition of vectors
    "+": (%, %) -> %

    -- Subtraction and unary minus of vectors
    "-": (%, %) -> %
    "-": % -> %

    -- Multiplication by scalars from base field / ring
    "*": (R, %) -> %
    "*": (%, R) -> %

    -- Equality of vectors
    "=": (%, %) -> Boolean

  add
    (x:% - y:%) :% == x + (-1)::R * y
    (-x:%) :% == (-1)::R * x
    (x:% * r:R) :% == r * x

    -- what about others?
    -- x = y ==


<<category VAC VectorAlgebraCategory>>=
)abbrev category VAC VectorAlgebraCategory
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 12 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
++
++ Axioms:
++   \spad{ (a+b)^c = a^c + b^c }
++   \spad{ a^b = -b^a }
++   \spad{ a^(b^c) = (a.c)*b - (a.b)*c }
++   \spad{ (abc) = (bca) } where \spad{(abc)} denotes \spad{(a^b).c}
++   \spad{ (abc) = 0 } implies that \spad{a, b, c} are linearly dependent
VectorAlgebraCategory(R : Ring) : Category == VectorSpaceCategory(R) with
    -- or Algebra(R) ?

    vector: Symbol -> %
      ++ Create a symbolic component-free vector object

    scalarZero: () -> %
      ++ Create a scalar zero object

    vectorZero: () -> %
      ++ Create a vector zero object

    isScalar?: % -> Boolean
      ++ Check if a given expression is scalar valued

    isVector?: % -> Boolean
      ++ Check if a given expression is vector valued

    zero?: % -> Boolean

    "*": (%, %) -> %
      ++ Dot/scalar product
      -- Possible confusion with inherited r:R*v:% from VSC?

    "^": (%, %) -> %
      ++ Vector cross/wedge product
      -- rather use "/\"?

    s3p: (%, %, %) -> %
      ++ Triple vector product

    simplify: % -> %
      ++ Simplify a given vector expression by first
      ++ bring it to the normal form, then apply
      ++ transformation rules

    identity?: (%, %) -> Boolean
      ++ Check if two expressions are equal in value

  add

    s3p(x:%, y:%, z:%) :% == (x^y) * z


<<domain VA VectorAlgebra>>=
)abbrev domain VA VectorAlgebra
++ Author: Raoul Bourquin
++ Date Created: 7 October 2012
++ Date Last Updated: 12 October 2012
++ Description:
++ Implementation of component-free vector algebra
++ based on the techniques described in the paper
++ "Rule-Based Simplification in Vector-Product Spaces"
++ by Songxin Liang and David J. Jeffrey
VectorAlgebra(R : Ring) : VectorAlgebraCategory(R) == Implementation where

  Exports == with

    --normalForm: % -> %
    -- What can we gain by exporting this?
      ++ Bring the vector expression into a normal form
      ++ of type [coef, sca, vec]
      ++ Example of a normal form:
      ++ -2 * (a.b)*(abc) * (c^d)
      ++ [-2, [[a, b],[a, b, c]], [c, d]]

    --termOrder:
    -- What can we gain by exporting this?
      ++ Reorder the terms by the term order constructed

    coerce: % -> OutputForm
      -- Used for printing?


  Implementation == add

    INT ==> Integer

    -- Basic data types used
    coePart == R
    scaPart == List List String
    vecPart == List String
    -- we dont want to use Strings, rather Exprs? Symbols? Variables?

    -- A single term is of the form alpha * a * v
    Term == Record(coe:R, sca:scaPart, vec:vecPart)

    -- A normal form is a sum of terms
    Rep := List Term

    -- Further structures used for contraction rules
    scaTerm == Record(coe2:R, sca2:scaPart)
    scaList == List(scaTerm)
    mixTerm == Record(scal: scaList, vec2: vecPart)

    -- Extract single parts out of terms
    -- Do we really need this?
    coefPart(x:Term) : R == x.coe
    scalarPart(x:Term) : scaPart == x.sca
    vectorPart(x:Term) : vecPart == x.vec


    -- Construct new domain elements

    scalarZero() : % == [ [0, [], []] ]::%

    vectorZero() : % == [ [0, [], ["0"]] ]::%
      -- TODO: Fix "0" string here

    vector(x:Symbol) : % == [ [1::R, [], [string x]] ]::%


    -- Check a term for beeing zero

    szero?(x:Term) : Boolean ==
      -- Coefficient is zero and there is no vector part
      -- But what about scalar part: scalar part could be zero
      -- if it contains a scalar product of orthogonal vectors.
      -- But: we can not make any assumptions on abstract vectors yet!
      x.coe = 0 and empty? x.vec

    vzero?(x:Term) : Boolean ==
      -- Vector is zero or multiplied by zero coefficient
      -- But what about scalar part: scalar part could be zero
      -- if it contains a scalar product of orthogonal vectors.
      -- But: we can not make any assumptions on abstract vectors yet!
      empty? x.vec or (x.coe = 0 and ~empty? x.vec)
      -- What about x.vec beeing a zero?
      -- Or a vector product with one factor a zero?

    zero?(x:%) : Boolean ==
      -- Buggy because of the above issues!
      xx := x::Rep
      result := true
      for tx in xx repeat
        not szero? tx or not vzero? tx => false


    -- Check shapes

    isScalar?(x:%) : Boolean ==
      xx := x::Rep
      result := true
      for tx in xx repeat
        not empty? tx.vec => result := false
      result

    -- Check if an expression is a true vector (possibly zero)
    -- or just a scalar expression. Examples for single terms:
    -- [a, [], []]  scalar
    -- [a, [...], []]  scalar
    -- [0, [...], []]  scalar
    -- [0, [], []]  scalar
    -- [0, [...], [0]]  zero-vector
    -- [a, [...], [0]]  zero-vector
    -- [a, [0,0], [0]]  zero-vector
    -- [a, [...], [v]]  vector
    -- [a, [...], [v, w]]  vector
    -- [0, [...], [u, v, w]]  vector? (triple product evaluated result in scalar!)
    isVector?(x:%) : Boolean ==
      xx := x::Rep
      -- Empty expression / normal form
      empty? xx => false
      -- We can only sum up compatible terms in the normal form
      -- hence search if there is a term which is not a vector
      result :Boolean := true
      for tx in xx repeat
        empty? tx.vec => (result := false)
      result


    -- Term order functions

    listOrder?(v1:vecPart, v2:vecPart) : Boolean ==
      empty? v1 => true
      empty? v2 => false
      n1 := #v1
      n2 := #v2
      n1 < n2 => true
      n1 > n2 => false

      -- Case n1 = n2
      result := true
      for i in 1..n1 repeat
        if v1(i) < v2(i) then
          result := true
          break

        if v1(i) > v2(i) then
          result := false
          break

      result

    listEq?(v1:vecPart, v2:vecPart) : Boolean ==
      empty? v1 and empty? v2 => true
      empty? v1 and not empty? v2 => false
      n1 := #v1
      n2 := #v2
      n1 ~= n2 => false

      -- Case n1 = n2
      result := true
      for i in 1..n1 repeat
        if v1(i) ~= v2(i) then
          result := false
          break

      result

    listListOrder?(s1:scaPart, s2:scaPart) : Boolean ==
      empty? s1 => true
      empty? s2 => false
      n1 := #s1
      n2 := #s2
      n1 < n2 => true
      n1 > n2 => false
      result := true

      -- Case n1 = n2
      for i in 1..n1 repeat
        if listOrder?(s1(i), s2(i)) and not listEq?(s1(i), s2(i)) then
          result := true
          break

        if not listOrder?(s1(i), s2(i)) then
          result := false
          break

      result

    listListEq?(s1:scaPart, s2:scaPart) : Boolean ==
      empty? s1 and empty? s2 => true
      empty? s1 and not empty? s2 => false
      n1 := #s1
      n2 := #s2
      n1 ~= n2 => false
      result := true

      -- Case n1 = n2
      for i in 1..n1 repeat
        if not listEq?(s1(i), s2(i)) then
          result := false
          break

      result

    termOrder?(t1:Term, t2:Term) : Boolean ==
      szero? t1 or vzero? t1 => true
      szero? t2 or vzero? t2 => false

      listOrder?(t1.vec, t2.vec) and not listEq?(t1.vec, t2.vec) => true
      not listEq?(t1.vec, t2.vec) => false

      listListOrder?(t1.sca, t2.sca) and not listListEq?(t1.sca, t2.sca) => true
      not listListEq?(t1.sca, t2.sca) => false

      true

    termEq?(t1:Term, t2:Term) : Boolean ==
      t1.coe = t2.coe and listListEq?(t1.sca, t2.sca) and listEq?(t1.vec, t2.vec) => true




    -- Bring the vector expression into a normal form
    -- of type [coef, sca, vec]
    -- Example of a normal form:
    -- -2 * (a.b)*(abc) * (c^d)
    -- [-2, [[a, b],[a, b, c]], [c, d]]
    normalForm(xx:Rep) : Rep ==
      -- for all tx in xx
      --   make scalar part and vector part in ascending order
      --   use transformation rules to check for zero
      --   collect non-zero terms in yy
      --   make yy in ascending order
      --   combine same terms
      -- return y

      -- TODO: Check for zeros:
      --         coe = 0
      --         sca is zero
      --         vec is zero
      --       We have
      --         a^a -> 0 and 0^a -> 0 and a^0 -> 0
      --         (aab) -> 0 and (abb) -> 0 and no check for (aba) because of sorting
      --       With assumption we could also do
      --         a*b -> 0 for a _|_ b
      result : Rep := empty()

      for tx in xx repeat
        -- Result term
        nt : Term := [tx.coe, [], []]

        -- Order scalar parts
        scaParts := tx.sca
        nsp : scaPart := empty()

        for sp in scaParts repeat
          if #sp = 1 then
            -- A single scalar part (how to obtain?)
            nsp := cons(sp, nsp)

          if #sp = 2 then
            -- A scalar product
            -- Axiom 2.2 applieas: a*b = b*a
            tmp := copy sp
            nsp := cons(sort(tmp), nsp)

          if #sp = 3 then
            -- A scalar triple product
            tmp := copy sp
            -- A small bubble sort, overkill but useful
            -- Counting version
            -- bubbleSort: (A, (S,S)->Boolen) -> (A, INT)
	    -- should go into library (sortpack)!
            wasordered := false
            exchanges : INT := 0
            while not wasordered repeat
                wasordered := true
                for i in 1..#tmp-1 repeat
                    if tmp.i > tmp.(i+1) then
                        t := tmp.i; tmp.i := tmp.(i+1); tmp.(i+1) := t
                        exchanges := exchanges + 1
                        wasordered := false

            nsp := cons(tmp, nsp)
	    if odd? exchanges then nt.coe := -nt.coe

        -- Sort the scalar parts
        nt.sca := sort(listOrder?, nsp)

        -- Order vector parts
        vp := tx.vec
        nvp : vecPart := empty()

        if #vp = 1 then
          -- A single vector part
          nvp := vp

        if #vp = 2 then
          -- A vector product
          -- Axiom 2.2 applieas: a^b = -b^a
          if vp(1) > vp(2) then
            nvp := [vp(2), vp(1)]
	    nt.coe := -nt.coe
          else
            nvp := copy vp

        nt.vec := nvp

        -- Add new term to the result
        result := cons(nt, result)

      -- Sort the terms in the result
      result := sort(termOrder?, result)


    -- Do we really want to make this available, for what?
    -- Issue: makes "something" looping
    --normalForm(x:%) : % ==
    --  normalForm(x::Rep)::%


    -- Implementation of algebraic operations

    -- Addition
    (x:% + y:%) : % ==
      zz := append(x::Rep, y::Rep)
      normalForm(zz)::%

    -- Scalar times vector
    (r:R * x:%) : % ==
      xx := x::Rep
      zz := [ [r*tx.coe, tx.sca, tx.vec] for tx in xx ]
      normalForm(zz)::%

    -- Scalar product of two vectors
    (x:% * y:%) : % ==
      xx := x::Rep
      yy := y::Rep

      zz : Rep := empty()

      for tx in xx repeat
        nx:INT := # tx.vec

        for ty in yy repeat
          ny:INT := # ty.vec

          -- TODO: I'd like to use a else-if structure here, but it becomes too clumpsy! maybe try using "iterate"
          vx := tx.vec
          vy := ty.vec

          if nx = 1 and ny = 1 then
            scap := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            m := [tx.coe * ty.coe, scap, []]@Term
            zz := cons(m,zz)

          if nx = 1 and ny = 2 then
            scap := cons([vx(1),vy(1),vy(2)], append(tx.sca,ty.sca))
            m := [tx.coe*ty.coe, scap, []]@Term
            zz := cons(m,zz)

          if nx = 2 and ny = 1 then
            scap := cons([vx(1),vx(2),vy(1)], append(tx.sca,ty.sca))
            m := [tx.coe*ty.coe, scap, []]@Term
            zz := cons(m,zz)

          if nx = 2 and ny = 2 then
            coep := tx.coe * ty.coe
            scap1 := [[vx(1),vy(1)], [vx(2),vy(2)]]
            scap2 := [[vx(1),vy(2)], [vx(2),vy(1)]]
            m1 := [coep, append(scap1,append(tx.sca,ty.sca)), []]@Term
            m2 := [(-1)*coep, append(scap2,append(tx.sca,ty.sca)), []]@Term
            zz := cons(m2, cons(m1,zz))

      zz := normalForm reverse! zz
      zz::%

    -- Cross product of two vectors
    (x:% ^ y:%) :% ==
      xx := x::Rep
      yy := y::Rep

      zz : Rep := empty()

      for tx in xx repeat
        nx:INT := # tx.vec

        for ty in yy repeat
          ny:INT := # ty.vec

          -- TODO: I'd like to use a else-if structure here, but it becomes too clumpsy! try using "iterate"
          vx := tx.vec
          vy := ty.vec

          if nx = 1 and ny = 1 then
            m := [tx.coe*ty.coe, append(tx.sca,ty.sca), append(tx.vec,ty.vec)]@Term
            zz := cons(m,zz)

          if nx = 1 and ny = 2 then
            coep := tx.coe * ty.coe
            scap1 := cons([vx(1),vy(2)], append(tx.sca,ty.sca))
            scap2 := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vy(1)]]@Term
            m2 := [(-1)*coep, scap2, [vy(2)]]@Term
            zz := cons(m2, cons(m1,zz))

          if nx = 2 and ny = 1 then
            coep := tx.coe * ty.coe
            scap1 := cons([vx(1),vy(1)], append(tx.sca,ty.sca))
            scap2 := cons([vx(2),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vx(2)]]@Term
            m2 := [(-1)*coep, scap2, [vx(1)]]@Term
            zz := cons(m2, cons(m1,zz))

          if nx = 2 and ny = 2 then
            coep := tx.coe * ty.coe
            scap1 := cons([vx(1),vx(2),vy(2)], append(tx.sca,ty.sca))
            scap2 := cons([vx(1),vx(2),vy(1)], append(tx.sca,ty.sca))
            m1 := [coep, scap1, [vy(1)]]@Term
            m2 := [(-1)*coep, scap2, [vy(2)]]@Term
            zz := cons(m2, cons(m1,zz))

      zz := normalForm reverse! zz
      zz::%


    -- Output of domain elements

    coerce(x : %) : OutputForm ==
      xx := x::Rep
      t1 := xx(1)
      t1.coe :: OutputForm

    -- What about latex printing?


    -- Transformation rules based on the axioms

    rule01(xx:Rep) : Rep ==
      ++ This rule implements the expansion according to the axiom
      ++ (abc)*d = (d*a)*(b^c) + (d*b)*(c^a) + (d*c)*(a^b)
      -- Less than 3 terms in the expression? (Why do we do this?)
      #xx < 3 => xx

      -- Not a real vector? In that case the shapes will not match anyway
      not isVector?(xx::%) => xx

      yy := sort!(termOrder?, copy(xx))

      result:Rep := empty()

      for tx in yy repeat
        -- Copy terms not suitable for this rule over to the result
        if #tx.vec ~= 1 or empty? tx.sca then
          result := cons(tx, result)

        -- Handle terms for which the rule applies
        else
          scaTerms := tx.sca
          n := #scaTerms
          atp:List String := empty()
          others:List List String := empty()

          -- Take out the first single triple product
          for i in 1..n repeat
            if #scaTerms(i) = 3 then
              atp := scaTerms(i)
              others := [scaTerms(j) for j in 1..n | j ~= i]
              break

          -- Take out the first single vector
          d := first tx.vec

          if #atp ~= 3 then
            -- No triple product found, add tx to the result and terminate
            result := cons(tx, result)
          else
            -- There was a triple product, add the 3 terms of the axioms RHS to the result
            t1:Term := [tx.coe, cons([d,atp(1)], others), [atp(2),atp(3)]]
            t2:Term := [tx.coe, cons([d,atp(2)], others), [atp(3),atp(1)]]
            t3:Term := [tx.coe, cons([d,atp(3)], others), [atp(1),atp(2)]]
            result := append(result, [t1,t2,t3])

      result


    rule02(xx:Rep) : Rep ==
      ++ This rule implements the expansion according to the axiom
      ++ (abc)*(d^h) = ((b^c)*(d^h))*a + ((c^a)*(d^h))*b + ((a^b)*(d^h))*c
      ++             =   ( (b*d)*(c*h) - (b*h)*(c*d) ) * a
      ++               + ( (c*d)*(a*h) - (c*h)*(a*d) ) * b
      ++               + ( (a*d)*(b*h) - (a*h)*(b*d) ) * c
      ++             =   (b*d)*(c*h)*a - (b*h)*(c*d)*a
      ++               + (c*d)*(a*h)*b - (c*h)*(a*d)*b
      ++               + (a*d)*(b*h)*c - (a*h)*(b*d)*c
      -- Less than 3 terms in the expression? (Why do we do this?)
      #xx < 3 => xx

      -- Not a real vector? In that case the shapes will not match anyway
      not isVector?(xx::%) => xx

      yy := sort!(termOrder?, copy(xx))

      result:Rep := empty()

      for tx in yy repeat
        -- Copy terms not suitable for this rule over to the result
        if #tx.vec ~= 2 or empty? tx.sca then
          result := cons(tx, result)

        -- Handle terms for which the rule applies
        else
          scaTerms := tx.sca
          n := #scaTerms
          atp:List String := empty()
          others:List List String := empty()

          -- Take out the first single triple product
          for i in 1..n repeat
            if #scaTerms(i) = 3 then
              atp := scaTerms(i)
              others := [scaTerms(j) for j in 1..n | j ~= i]
              break

          -- Take out the first two single vectors
          d := first tx.vec
          h := second tx.vec

          if #atp ~= 3 then
            -- No triple product found, add tx to the result and terminate
            result := cons(tx, result)
          else
            -- There was a triple product, add the 6 terms of the axioms RHS to the result
            a := atp(1)
            b := atp(2)
            c := atp(3)
            t1:Term := [ tx.coe, append(others, [[b,d], [c,h]]), [a]]
            t2:Term := [-tx.coe, append(others, [[b,h], [c,d]]), [a]]
            t3:Term := [ tx.coe, append(others, [[c,d], [a,h]]), [b]]
            t4:Term := [-tx.coe, append(others, [[c,h], [a,d]]), [b]]
            t5:Term := [ tx.coe, append(others, [[a,d], [b,h]]), [c]]
            t6:Term := [-tx.coe, append(others, [[a,h], [b,d]]), [c]]
            result := append(result, [t1,t2,t3,t4,t5,t6])

      result
