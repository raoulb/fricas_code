)abbrev package DISPERS Dispersion
++ Author: Raoul Bourquin
++ Date Created: 30 August 2014
++ Date Last Updated: 30 August 2014
++ Description:
++ Compute the dispersion of polynomials.
++ References:
++ Yiu-Kwong Man and Francis J. Wright,
++ 'Fast Polynomial Dispersion Computation and its Application to Indefinite Summation',
++ Proceedings of the International Symposium on Symbolic and Algebraic Computation, 1994, Pages 175-180
++ http://dl.acm.org/citation.cfm?doid=190347.190413
Dispersion(R) : Exports == Implementation where
--Dispersion(R : CommutativeRing, UP : UnivariatePolynomialCategory R) : Exports == Implementation where
  --R : Ring -- Just an arbitrary commutative ring
  --R : Join(UniqueFactorizationDomain, CharacteristicZero)
  R : Join(EuclideanDomain, CharacteristicZero, RetractableTo Integer, LinearlyExplicitRingOver Integer)

  NNI ==> NonNegativeInteger
  Z ==> Integer
  QR ==> Fraction(R)
  --OSZ ==> Set(OrderedCompletion(Z))

  --P ==> Polynomial(R)
  UP ==> SparseUnivariatePolynomial(P)

  -- We need to factor over R[x]
  S ==> Symbol
  P ==> Polynomial(R)
  MVF ==> MultivariateFactorize(S, IndexedExponents S, R, P)



  Exports ==> with

    shift : (P, Z) -> P
      ++

    dispersion : P -> Z
      ++

    dispersion : (P, P) -> Z
      ++

    --dispersionSet : P -> OrderedSet(Z)
      ++

    --dispersionSet: (P, P) -> OrderedSet(Z)
      ++


  Implementation ==> add


    shift(p:P, n:Z) : P ==
      x := first variables p
      eval(p, x, x::P+n::P)


    innerDispersion(p:UP, q:UP, s:Symbol) : Z ==
      degp := degree(p)
      degq := degree(q)
      -- Dispersion for constant polynomials is always zero
      degp < 1 => 0
      degq < 1 => 0
      -- Factor polynomials over R
      fp := factors factor(p)$MVF
      fq := factors factor(q)$MVF
      dis : Z := 0
      for pi in fp repeat
        for qi in fq repeat
          fpi := pi.factor
          fqi := qi.factor
          -- Degree check
          dpi := degree(fpi)
          dqi := degree(fqi)
          (dpi ~= dqi) => "iterate"

          an := leadingCoefficient(fpi)
          bm := leadingCoefficient(fqi)
          (an ~= bm) => "iterate"

          an1 := coefficient(fpi, (dpi-1)::NNI)
          bm1 := coefficient(fqi, (dqi-1)::NNI)

          alpha : QR := retract(bm1 - an1)@R / retract(dpi*an)@R
          --retractIfCan(alpha)@Union(R,"failed") case "failed" ==> "iterate"
          -- We know alpha is not a true quotient
          --a := retract(numer(alpha))@Z
          retractIfCan(alpha)@Union(Z,"failed") case "failed" ==> "iterate"
          a := retract(alpha)@Z

          print(a::OutputForm)

          (a <= dis) => "iterate"

          pim := multivariate(fpi, s)
          qim := multivariate(fqi, s)
          (dpi > 1) and (shift(pim, a) ~= qim) => "iterate"

          dis := a

      dis


    dispersion(p:P) : Z ==
      v := variables(p)
      -- What to do if polynomial is multivariate?
      --#v ~= 1 => "failed"
      x := first v
      pu := univariate(p, x)
      innerDispersion(pu, pu, x)


    dispersion(p:P, q:P) : Z ==
      vp := variables(p)
      vq := variables(q)
      -- What to do if polynomials are multivariate?
      --#vp ~= 1 or #vq ~= 1 => "failed"
      --first vp ~= first vq => "failed"
      x := first vp
      pu := univariate(p, x)
      qu := univariate(q, x)
      innerDispersion(pu, qu, x)
